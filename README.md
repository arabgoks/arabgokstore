https://muhammad-hafizh47-arabgokstore.pbp.cs.ui.ac.id/

1. - Membuat sebuah proyek django baru:
Pertama-tama dalam membuat projek django baru, saya membuat repository github terlebih dahulu sesuai dengan nama aplikasi saya yaitu arabgokstore. Lalu, saya membuat direktori baru dan membuka cmd untuk mengaktifkan virtual environtment. Setelah itu, saya membuat file baru yaitu "requirements.txt" pada direktori yang sama dan melakukan instalasi terhadap apa yang ada pada isi file tersebut. Selesai instalasi, saya membuat proyek django baru dengan perintah "django-admin startproject arabgokstore .".
- Membuat aplikasi dengan nama main pada proyek tersebut:
Pertama, saya membuka direktori utama dulu yaitu arabgokstore dan mengaktifkan virtual environments nya pada cmd yang telah dipakai sebelumnya. Lalu, saya membuat aplikasi dengan nama main dengan menjalankan perintah "python manage.py startapp main" maka aplikasi main akan terbentuk dan berisi struktur awal sebagai pengembangan aplikasi ini.
- Melakukan routing agar dapat menjalankan aplikasi main:
Jikalau sudah mengerjakan bagian models dan views untuk pengembangan tampilan aplikasi main tersebut, maka buatlah file urls.py dalam folder main tersebut dan mengisi file tersebut dengan konfigurasi routing yang akan digunakan. Setelah itu, melengkapi kode rute URL pada folder proyek (bukan main) dengan meng-include rute URL dari aplikasi main. Lalu, tinggal jalankan proyek tersebut dengan runserver dan membuka localhost untuk mengecek web yang telah saya buat
- Membuat model pada aplikasi main dengan nama Product dan atribut wajib :
Pertama, saya buka dulu file models.py yang ada pada folder aplikasi main. Lalu, saya mengisi atribut-atribut yang dibutuhkan ke dalam class Product sesuai dengan tipe masing-masing.
- embuat sebuah fungsi pada views.py untuk dikembalikan ke dalam sebuah template HTML :
Pertama, buka terlebih dahulu file views.py yang ada pada folder aplikasi main. Lalu, saya membuat 3 variabel dalam fungsi show_main ini agar membantu menampilkan ke template HTML. Tiga variabel tersebut berisi nama aplikasi saya, lalu nama saya, dan kelas saya.
- Membuat sebuah routing pada urls.py aplikasi main untuk memetakan fungsi yang telah dibuat pada views.py :
membuat file urls.py sebagai konfigurasi routing aplikasi main, lalu saya mengimpor fungsi path untuk mendefinisikan pola URL yang akan dipakai. Lalu, fungsi path tersebut memanggil fungsi show_main yang telah dibuat pada views.py
Django akan mencocokkan URL tersebut dengan yang ada di urls.py, jika cocok maka akan menjalankan yang ada di views
- Melakukan deployment ke PWS terhadap aplikasi yang dibuat:
Pertama, membuat new project terlebih dahulu di PWS dan memberi nama projeknya yaitu arabgokstore. Lalu, PWS memberikan informasi project credentials nya dan project command nya yang akan digunakan nanti nya. Setelah itu, saya mengubah raw editor pada tab environs yang ada di PWS dengan code yang ada dari .env.prod. Lalu, saya menambahkan URL deployment PWS saya ke allowed hosts pada settings.py aplikasi saya. Setelah itu, saya melakukan push ke PWS dan memasukkan username dan password credentials yang telah diberikan oleh PWS sebelumnya. Terakhir, saya hanya perlu menjalankan git push pws master setelah melakukan add dan commit untuk deployment aplikasi saya.

2. ini adalah link gambar bagan yang berisi request client ke web aplikasi : https://drive.google.com/file/d/1-55tYEYnPfqzJMagaxpb124xBIS35KlT/view?usp=sharing
Penjelasan: Kaitan antara urls.py, views.py, models.py, dan html adalah pertama-tama browser kirim request dan dicek oleh urls.py pada direktori projek arabgokstore, lalu kalau cocok akan diteruskan ke urls.py pada direktori aplikasi main, urls.py pada direktori main menunjuk ke fungsi di views.py, views.py dapat mengambil data dari models.py, lalu views.py me-render HTML template dengan data context, dan browser menampilkan hasil HTML ke user.

3. Peran settings.py dalam proyek django adalah adalah sebagai pusat konfigurasi yang mengatur segala aspek aplikasi, mulai dari daftar aplikasi aktif (INSTALLED_APPS), database, dan lainnya. Semua komponen Django merujuk ke file ini agar proyek bisa berjalan sesuai aturan yang ditentukan. Tanpa settings.py, Django tidak akan tahu cara menghubungkan ke database, menampilkan template, atau memproses request sehingga proyek tidak akan bisa dijalankan maupun diakses di browser. 

4. Cara kerja migrasi database di Django adalah
- Saat kita menambah atau mengubah file models.py, django akan mendeteksi perubahan tersebut.
- Lalu, menjalankan perintah python manage.py makemigrations, perintah ini membuat file migration (0001_initial.py) di folder migrations. File ini berisi instruksi Python yang menjelaskan perubahan apa yang harus dilakukan pada database.
- Setelah itu, menjalankan perintah python manage.py migrate, perintah ini menjalankan file migrasi tadi ke dalam database. 
- Terkhir, django akan membuat riwayat migrasi bernama django_migrations di database untuk melacak migrasi mana saja yang udah dijalankan. Jadi, ketika ada migrasi baru, maka hanya migrasi tersebut yang dijalankan, bukan semuanya dari awal.

5. Menurut saya, alasan framework Django dijadikan permulaan pembelajaran adalah karena django sudah menyediakan kebutuhan-kebutuhan dasar, seperti database ORM, routing URL, sistem autentikasi, dan lainnya. Hal ini menurut saya membantu mahasiswa untuk langsung belajar konsep pengembangan web tanpa harus melakukan instalasi dan coding dari 0. Django juga menggunakan bahasa Python, yang sintaksnya sederhana dan mudah dibaca dibandingkan bahasa lain sehingga lebih mudah dipahami untuk dijadikan permulaan pembelajaran. Django juga menggunakan konsep MVT, konsep ini menurut saya memperkenalkan bagaimana cara kerja pengembangan software yang rapi dan terstruktur.

6. Feedback saya untuk asdos tutorial 1 adalah asdos nya sangat baik, responsif, dan sangat membantu mahasiswa yang kesulitan.


TUGAS 3
1. Data delivery dibutuhkan dalam pengembangan sebuah platform karena menjadi mekanisme utama untuk memastikan pertukaran informasi antar komponen sistem maupun dengan layanan eksternal berjalan dengan cepat, konsisten, dan efisien. Melalui data delivery, client dan server dapat berkomunikasi menggunakan format standar seperti JSON atau XML sehingga informasi yang dikirim lebih mudah diproses lintas perangkat maupun bahasa pemrograman. Selain itu, data delivery mendukung integrasi sistem (misalnya lewat API), memungkinkan pemuatan data di latar belakang sehingga user tetap bisa berinteraksi dengan aplikasi, serta menjaga informasi yang ditampilkan. Tanpa mekanisme ini, platform hanya bisa bersifat statis, tidak mampu mendukung interaktivitas real-time, integrasi eksternal, maupun pengalaman user yang lancar.

2. Menurut saya, JSON lebih unggul dibandingkan XML dalam banyak skenario karena formatnya ringkas, sederhana, serta lebih mudah dipahami baik oleh manusia maupun komputer. JSON menggunakan pasangan key-value yang mirip dengan struktur data di banyak bahasa pemrograman sehingga proses konversi dan pengolahan data menjadi lebih cepat serta efisien. Sebaliknya, XML menggunakan banyak tag pembuka dan penutup yang membuat dokumen menjadi panjang dan ukuran data lebih besar. Hal inilah yang membuat JSON lebih populer di era aplikasi web dan mobile modern, karena parsing-nya lebih cepat, lebih efisien dalam useran data, serta lebih banyak diintegrasikan pada API dan teknologi pengembangan terkini.

3. Method is_valid() pada form Django digunakan untuk mengecek apakah input yang dikirim user sudah sesuai dengan aturan validasi yang berlaku. Validasi ini mencakup aturan bawaan seperti tipe data, panjang karakter, dan field wajib, serta aturan tambahan yang bisa kita buat sendiri. Jika validasi berhasil, method ini mengembalikan True dan data yang sudah melalui proses pembersihan dapat diakses melalui atribut cleaned_data. Sebaliknya, jika ada kesalahan, method akan mengembalikan False dan detail error akan disimpan di atribut errors. Kita membutuhkan method ini karena ia menjadi lapisan pengaman penting sebelum data disimpan ke database atau diproses lebih lanjut. Dengan adanya validasi, sistem dapat menjaga konsistensi data, mencegah input yang salah format, serta mengurangi risiko bug maupun masalah keamanan.

4. Kita memerlukan csrf_token pada form di Django karena token ini berfungsi sebagai perlindungan terhadap serangan Cross-Site Request Forgery (CSRF). Token tersebut memastikan setiap permintaan POST benar-benar datang dari interaksi user di aplikasi kita sendiri, bukan dari situs lain yang berusaha mengirimkan permintaan palsu. Tanpa adanya csrf_token, server tidak punya cara untuk membedakan mana request asli dan mana yang disusupi. Celah ini bisa dieksploitasi penyerang, misalnya dengan menaruh form tersembunyi atau tautan berbahaya. Jika user yang sedang login mengaksesnya, browser tetap akan mengirimkan cookie sesi sehingga tindakan berbahaya bisa dijalankan seakan-akan oleh user tersebut.

5. Saya mulai dengan merapikan model Product, menambahkan field yang diperlukan serta helper (misalnya properti pendukung) agar data lebih mudah digunakan di tampilan. Berikutnya, saya membuat ProductForm sebagai form input dan menghubungkannya ke template create_product.html agar user bisa mengisi data produk baru langsung dari halaman web. Untuk menampilkan data yang sudah tersimpan, saya membuat home.html yang merender daftar produk beserta informasi kunci, dan menyediakan tautan ke product_detail.html agar detail tiap produk bisa dilihat. Setelah itu, saya menambahkan fungsi pada views.py untuk menangani proses pembuatan produk baru serta fungsi lain untuk menyajikan data produk dalam format JSON maupun XML sehingga lebih fleksibel jika data ingin diakses sebagai API. Dari sisi keamanan, saya menambahkan pengaturan CSRF_TRUSTED_ORIGINS agar form hanya menerima input dari sumber tepercaya dan tidak mudah dieksploitasi penyerang. Terakhir, saya membuat template utama base.html sebagai kerangka dasar agar semua halaman memiliki struktur yang konsisten dan lebih mudah dikelola.

6. Feedback untuk asdos, asdos sudah sangat baik dalam menjalankan tugas dan membantu mahasiswa ketika ada kendala dalam menjalankan tutorial.

Screenshot hasil akses URL pada Postman : https://drive.google.com/drive/folders/15cqnBZJyB0ylWRwpMaxHY9Nbh378vOHi?usp=sharing


TUGAS 4
1. Django AuthenticationForm adalah form bawaan yang digunakan secara default dalam LoginView untuk memfasilitasi proses login user. Form ini mengambil parameter request pada konstruktor-nya dan menyimpan objek request tersebut untuk keperluan subclass atau validasi tambahan. Salah satu fungsi pentingnya adalah method confirm_login_allowed(user), yang secara standar akan menolak login jika atribut is_active dari user adalah False, tapi developer dapat mengoverride method tersebut untuk membuat kebijakan berbeda mengenai pengguna yang boleh login. Kelebihannya dari AuthenticationForm ini adalah integrasi bawaannya dengan LoginView sehingga tidak perlu membuat form login dari nol, sudah siap dengan berbagai fitur keamanan dasar seperti memeriksa status aktif user, dan fleksibilitas untuk dikustomisasi lewat subclass jika ingin memodifikasi perilaku login (misalnya menerima user yang nonaktif atau memberi aturan khusus). Namun, kekurangannya adalah form ini mengasumsikan struktur tertentu dari model User default (seperti adanya field username, is_active, dll), jadi jika menggunakan model User custom dengan field berbeda, mungkin perlu override banyak bagian. Lalu, pesan kesalahan (error message) yang relatif generik karena desain keamanan dan tidak ada mekanisme throttle login attempts secara langsung dari form ini sehingga tetap perlu ditambah perlindungan ekstra jika proyek rentan terhadap serangan brute-force.

2. Autentikasi berfokus pada proses memverifikasi identitas pengguna, misalnya dengan mencocokkan username dan password yang dimasukkan dengan data yang tersimpan di sistem. Otorisasi di sisi lain, menentukan apa saja yang boleh dilakukan oleh pengguna setelah mereka berhasil diautentikasi, seperti akses ke halaman admin atau izin untuk mengedit data tertentu. Django mengimplementasikan autentikasi melalui framework bawaan django.contrib.auth yang menyediakan model User, backend autentikasi, serta form seperti AuthenticationForm dan LoginView untuk proses login. Sementara itu, otorisasi diimplementasikan dengan sistem permission dan group, dimana setiap user dapat memiliki hak akses tertentu (misalnya add, change, delete, atau view pada suatu model) dan bisa dikelompokkan dalam group yang memudahkan pengaturan izin. Django juga menyediakan decorator seperti @login_required untuk memastikan hanya pengguna terautentikasi yang dapat mengakses view tertentu, serta @permission_required untuk membatasi akses berdasarkan izin yang lebih spesifik. Dengan demikian, autentikasi memastikan “siapa” pengguna, sedangkan otorisasi memastikan “apa yang boleh” dilakukan pengguna dalam aplikasi.

3. Dalam aplikasi web, cookies dan session digunakan untuk menyimpan state karena HTTP bersifat stateless, tetapi keduanya memiliki kekuatan dan keterbatasan masing-masing. Cookies adalah data kecil yang disimpan di perangkat klien (browser) sehingga bisa bertahan antar permintaan dan bahkan antar sesi browser (tergantung pengaturan waktu kedaluwarsa) dan langsung dikirim kembali ke server pada setiap permintaan ke domain yang sama. Namun, karena data berada di klien, cookies rentan terhadap manipulasi, pembacaan oleh pihak tidak sah (termasuk lewat script jika tidak hati-hati), dan ukurannya dibatasi (sekitar 4 KB) sehingga tidak cocok untuk menyimpan banyak data sensitif. Di sisi lain, session menyimpan data di sisi server, dan klien hanya menyimpan session ID (biasanya dalam cookie). Ini membuat penyimpanan data lebih aman dan lebih fleksibel karena server bisa menyimpan data besar atau sensitif tanpa langsung menaruhnya di klien, serta server bisa mengendalikan kapan session tersebut habis atau dihapus. Kekurangannya, session memerlukan penyimpanan di sisi server sehingga bisa memakan sumber daya jika pengguna banyak, dan dapat menyulitkan jika aplikasi berjalan di banyak server (harus ada mekanisme sinkronisasi session, load balancing, shared storage). Maka hal ini ditekankan bahwa menyimpan semua informasi lewat cookie (di klien) kurang aman dibanding menyimpan hanya session ID sementara data detailnya di server, serta bahwa session cocok ketika data yang dibutuhkan cukup banyak dan sensitif, sementara cookie cocok untuk data ringan dan tidak kritis.

4. Penggunaan cookies dalam pengembangan web tidak sepenuhnya aman secara default karena terdapat sejumlah risiko potensial yang harus diwaspadai, seperti pencurian cookies melalui serangan Cross-Site Scripting (XSS), penyalahgunaan cookies untuk session hijacking, atau intersepsi cookies pada koneksi yang tidak terenkripsi. Cookies juga rentan dimanipulasi karena disimpan di sisi klien. Oleh karena itu, developer perlu menerapkan langkah-langkah pengamanan tambahan. Django secara bawaan telah menyediakan beberapa mekanisme untuk mengurangi risiko ini, misalnya dengan mengaktifkan flag HttpOnly agar cookies tidak bisa diakses lewat JavaScript berbahaya, flag Secure agar cookies hanya dikirim melalui koneksi HTTPS, serta SameSite untuk membatasi pengiriman cookies lintas situs sehingga dapat mencegah Cross-Site Request Forgery (CSRF). Selain itu, Django memiliki middleware CSRF protection dan session framework yang menyimpan data di sisi server, sementara browser hanya menyimpan session ID dalam bentuk cookie, sehingga informasi sensitif tidak langsung tersebar. Dengan cara ini, Django dapat membantu menjaga keamanan cookies.

5. Langkah pertama adalah saya menambahkan halaman registrasi agar pengguna baru bisa membuat akun. Hal ini dilakukan dengan membuat view khusus yang memanfaatkan UserCreationForm sehingga setiap data akun baru langsung tersimpan di database. Setelah itu, saya juga menambahkan mekanisme login dengan membuat view login_user yang menggunakan AuthenticationForm. Form ini memvalidasi username dan password, lalu jika benar, fungsi login() dipanggil untuk menyimpan status pengguna ke dalam session. Sebaliknya, untuk keluar dari aplikasi, saya membuat view logout_user dengan memanfaatkan fungsi logout() sehingga session yang tersimpan langsung dihapus dan pengguna benar-benar keluar dari sistem.
Setelah fitur login dan registrasi berfungsi, saya membuat dua akun user berbeda melalui halaman registrasi yang sudah disediakan. Untuk masing-masing user tersebut, saya menambahkan tiga data produk baru ke dalam sistem. Agar setiap produk bisa terhubung dengan usernya, saya menambahkan relasi ForeignKey dari model produk ke model user. Dengan begitu, setiap produk akan otomatis tercatat dimiliki oleh user tertentu dan nantinya bisa difilter berdasarkan siapa yang sedang login.
Pada halaman utama aplikasi, saya menampilkan nama user yang sedang login dengan memanfaatkan objek request.user. Dengan cara ini, selain daftar produk milik pengguna, aplikasi juga memperlihatkan identitas user yang sedang aktif. Terakhir, saya mengatur penyimpanan informasi last_login menggunakan cookie. Saat user berhasil login, saya menyimpan waktu login terakhirnya ke dalam cookie, lalu menampilkannya kembali pada halaman utama sebagai informasi tambahan. Ketika pengguna melakukan logout, cookie tersebut saya hapus agar data tidak tertinggal.


TUGAS 5
1. Jika ada beberapa CSS selector yang mengatur suatu elemen HTML, browser akan menentukan gaya yang dipakai berdasarkan urutan prioritas. Aturan dengan !important akan selalu diutamakan dibandingkan aturan biasa. Jika tidak ada !important, maka aturan dengan spesifisitas lebih tinggi yang dipakai, misalnya inline style lebih kuat daripada ID, ID lebih kuat daripada class, dan class lebih kuat daripada selector elemen. Jika spesifisitas sama, maka aturan yang muncul paling akhir di file CSS atau urutan link stylesheet akan menang. Jika tidak ada aturan khusus, elemen bisa mengambil nilai properti yang diwariskan dari elemen induknya. Jadi secara sederhana: !important -> spesifisitas -> urutan penulisan -> inheritance.

2. Responsive design penting dalam pengembangan aplikasi web karena memungkinkan tampilan website beradaptasi secara otomatis dengan berbagai ukuran layar, mulai dari desktop hingga mobile. Dengan cara ini, user tetap dapat mengakses informasi dengan nyaman tanpa harus melakukan zoom in atau scroll berlebihan sehingga pengalaman user menjadi lebih baik dan konsisten. Misalnya, aplikasi e-commerce seperti Tokopedia atau Shopee sudah menerapkan responsive design dengan baik. Tampilan produknya tetap rapi dan navigasinya mudah meski dibuka di layar kecil. Sebaliknya, beberapa website lama dari institusi pemerintah masih ada yang belum menggunakan responsive design, sehingga jika diakses melalui ponsel tampilan teks dan menu menjadi berantakan serta sulit digunakan. Hal ini menunjukkan bahwa penerapan responsive design bukan hanya meningkatkan kenyamanan user, tetapi juga mendukung aksesibilitas dan efektivitas aplikasi web di berbagai perangkat.

3. Margin, border, dan padding adalah tiga konsep penting dalam CSS box model yang membedakan ruang di sekitar elemen. Margin adalah jarak antara elemen dengan elemen lain di sekitarnya sehingga berfungsi sebagai ruang luar. Border adalah garis pembatas yang mengelilingi elemen, letaknya berada di antara margin dan padding. Sedangkan padding adalah ruang di dalam elemen, tepatnya jarak antara konten (contohnya teks atau gambar) dengan border elemen tersebut. Implementasinya cukup sederhana, misalnya margin: 20px -> untuk memberi jarak luar 20 piksel, border: 2px solid black -> untuk menambahkan garis hitam tebal 2 piksel di sekeliling elemen, dan padding: 10px -> untuk memberikan ruang di dalam elemen agar konten tidak menempel langsung ke border. Dengan memahami perbedaan ini, pengembang bisa mengatur tata letak elemen web agar terlihat rapi dan mudah dibaca.

4. Flexbox dan Grid Layout adalah dua sistem tata letak modern di CSS yang membantu mengatur posisi elemen dengan lebih fleksibel dan efisien. Flexbox dirancang untuk mengatur elemen dalam satu dimensi, baik secara horizontal (row) maupun vertikal (column) sehingga sangat berguna untuk menyusun item dalam baris atau kolom yang rapi, misalnya membuat navbar, card list, atau form yang responsif. Sementara itu, Grid Layout bekerja dalam dua dimensi, yaitu baris dan kolom sekaligus sehingga cocok untuk membangun struktur halaman yang kompleks, seperti layout majalah, dashboard, atau template website dengan banyak bagian. Keduanya mempermudah developer dalam membuat desain responsif karena elemen dapat menyesuaikan ukuran layar tanpa harus menulis banyak kode tambahan dan menjadikan tampilan web lebih konsisten dan teratur di berbagai perangkat.

5. - Untuk mengimplementasikan fungsi untuk menghapus dan mengedit product adalah pertama menambahkan fungsi edit_product dan delete_product nya ke views.py. Lalu, membuat file baru dengan nama edit_product.html dan mengisi code nya. Setelah itu, menambahkan import fungsi-fungsi yg telah dibuat pada urls.py yg ada pada direktori main dan menambahkan path url tersebut ke urlpatterns nya. Terakhir, menambah code pada main.html yaitu loop pada product_list agar memunculkan tombot edit dan juga delete pada setiap card product.
- Kustomisasi halaman login, register, tambah product, edit product, dan detail product semenarik mungkin.
Saya melakukan kustomisasi pada halaman login dan register dengan menambahkan foto background bola, lalu mengganti warna pada kotak menjadi lebih gelap, serta mengganti warna yang tadi nya hijau (pada tutorial) menjadi warna merah. Setelah itu, untuk halaman edit product, saya melakukan kustom dengan menambahkan header bewarna merah tua dan background berwarna merah muda, serta mengganti juga warna publish product dan lainnya dengan warna merah. Terakhir, untuk halaman detail product, saya melakukan kustom dengan menambahkan eader dengan warna yang sama merah tua dan dengan background warna yg sama juga yaitu merah muda. Tetapi, saya juga melakukan kustom pada layout nya yaitu dengan gambar letaknya dikiri dan di kanan dicantumkan harga, nama product, stock, brand, description, dan lainnya.
- Kustomisasi halaman daftar product menjadi lebih menarik dan responsive.
Saya melakukan kustom pada halaman daftar produk dengan warna background nya putih keabuan, lalu menampilkan navbar diatas dan juga cardproduct yang berisi daftar daftar produknya. Saya juga menambahkan select option gitu untuk product type (All product atau My Product) dan Categories (All Categories, Jersey, Jaket, Bola, dll).
- Jika pada aplikasi belum ada product yang tersimpan, halaman daftar product akan menampilkan gambar dan pesan bahwa belum ada product yang terdaftar.
Saya menambahkan gambar no-product dan pesan "No Product Found" untuk tampilan saat belum ada produk sesuai keinginan user.
- Jika sudah ada product yang tersimpan, halaman daftar product akan menampilkan detail setiap product dengan menggunakan card (tidak boleh sama persis dengan desain pada Tutorial!).
Saya melakukan kustom pada cardproduct sebagai tampilan daftar product jika sudah ada product yang tersimpan, dimana saya mengubah format nya menjadi tanggal, viewsnya, harga, dan deskripsi singkat nya, serta perubahan warna menjadi merah muda untuk setiap card nya. 
- Untuk setiap card product, buatlah dua buah button untuk mengedit dan menghapus product pada card tersebut!
Pada setiap card product, saya juga menambahkan dua buah button untuk fitu edit dan hapus product pada setiap card (jika card tersebut milik user yang sedang aktif) dengan tombol edit yang berwarna putih keabuan dan fitur hapus dengan warna merah.
- Di desktop, menu tampil berjajar (Home, Create Product, dan kategori: Apparel, Sepatu, Aksesoris, Bola). Di mobile, ada ikon hamburger yang saat diklik menampilkan menu. Setiap kategori memakai query di URL, jadi saat diklik akan memfilter produk di halaman utama, khusus “Apparel” saya membuat otomatis menampilkan gabungan jersey dan jaket. Link yang sedang aktif ditandai (teks lebih tebal/putih) supaya jelas user lagi di halaman mana. Navbar juga menampilkan info user dan tombol Logout kalau sudah login.